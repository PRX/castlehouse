#!/usr/bin/env ruby
require "bundler/inline"

WDIR = File.expand_path(File.dirname(__FILE__))
CFG_FILE = "#{WDIR}/config.xml"
EXE_FILE = "#{WDIR}/clickhouse/clickhouse"
PID_FILE = "#{WDIR}/clickhouse/server.pid"
LOG_FILE = "#{WDIR}/clickhouse/server.log"
ELOG_FILE = "#{WDIR}/clickhouse/server-error.log"

gemfile do
  source "https://rubygems.org"

  gem "colorize"
  gem "date"
  gem "dotenv"
end

Dotenv.load
CLICKHOUSE_DB = ENV["CLICKHOUSE_DB"].to_s
GOOGLE_STORAGE_BUCKET = ENV["GOOGLE_STORAGE_BUCKET"].to_s
GOOGLE_STORAGE_HMAC_KEY_ID = ENV["GOOGLE_STORAGE_HMAC_KEY_ID"].to_s
GOOGLE_STORAGE_HMAC_KEY_SECRET = ENV["GOOGLE_STORAGE_HMAC_KEY_SECRET"].to_s

def usage
  puts ""
  puts "usage: " + "castlehouse <command>".cyan.underline + " [parameters]"
  puts ""
  puts "  castlehouse start".cyan + " - start clickhouse server in foreground"
  puts "  castlehouse daemon".cyan + " - start clickhouse server in background"
  puts "  castlehouse stop".cyan + " - stop clickhouse server"
  puts "  castlehouse setup".cyan + " - create rollup tables"
  puts "  castlehouse reset".cyan + " - drop and recreate rollup tables"
  puts "  castlehouse client".cyan + " - start clickhouse client"
  puts ""
  puts "  castlehouse load latest".cyan + " - load some rollup data"
  puts "  castlehouse load 2024/03/28".cyan + " - load day of rollup data"
  puts "  castlehouse load 2024/03/*".cyan + " - load month of rollup data"
  puts "  castlehouse load 2024/**".cyan + " - load year of rollup data"
  puts ""
  puts "  castlehouse queue backfill".cyan + " - use a materialized view to backfill all data"
  puts "  castlehouse queue increments".cyan + " - use a materialized view to increment"
  puts ""
  exit 1
end

# check if pidfile exists AND is running
def check_pid
  begin
    if File.exist?(PID_FILE)
      pid = File.read(PID_FILE).to_i
      Process.getpgid(pid)
      pid
    else
      false
    end
  rescue Errno::ESRCH
    File.delete(PID_FILE)
    false
  end
end

# read tables directory
def tables
  Dir.glob("#{WDIR}/tables/*.sql").map do |filename|
    [File.basename(filename, File.extname(filename)), filename]
  end.to_h
end

# clickhouse client querying
def run_query(sql_or_file)
  if File.file?(sql_or_file)
    `cd #{WDIR}/clickhouse && ./clickhouse client --queries-file "#{sql_or_file}" 2>&1`
  else
    `cd #{WDIR}/clickhouse && ./clickhouse client --query "#{sql_or_file}" 2>&1`
  end
end

# install and start clickhouse server
def start(daemon = false)
  abort "server already running" if check_pid
  File.delete(LOG_FILE) if File.exist?(LOG_FILE)
  File.delete(ELOG_FILE) if File.exist?(ELOG_FILE)

  unless File.exist?(EXE_FILE)
    print "downloading clickhouse dev server... "
    output = `cd #{WDIR} && mkdir -p clickhouse && cd clickhouse && curl -sS https://clickhouse.com/ | sh 2>&1`
    if $?.success?
      puts "done".green
    else
      abort "woh, that failed spectacularly!".red + "\n#{output}"
    end
  end

  opts = [
    "--config-file=#{CFG_FILE}",
    "--log-file=#{LOG_FILE}",
    "--errorlog-file=#{ELOG_FILE}",
    "--pid-file=#{PID_FILE}"
  ]
  opts << "--daemon" if daemon
  envs = [
    "GOOGLE_STORAGE_HMAC_KEY_ID=#{GOOGLE_STORAGE_HMAC_KEY_ID}",
    "GOOGLE_STORAGE_HMAC_KEY_SECRET=#{GOOGLE_STORAGE_HMAC_KEY_SECRET}"
  ]
  cmd = "cd #{WDIR}/clickhouse && #{envs.join(" ")} ./clickhouse server #{opts.join(" ")}"

  if daemon
    print "starting clickhouse server... "
    output = `#{cmd} 2>&1`
    if $?.success?
      puts "started".green
    else
      abort "woh, that failed spectacularly!".red + "\n#{output}"
    end
  else
    puts "starting clickhouse server... \n\n"
    STDOUT.sync = true
    trap("INT") do
      while check_pid
        sleep 0.1
      end
    end
    system(cmd)
  end
end

# stop daemonized clickhouse server
def stop
  if pid = check_pid
    print "stopping clickhouse server... "
    Process.kill("INT", pid)
    while check_pid
      sleep 0.1
    end
    puts "stopped".green
  else
    puts "server not running"
  end
end

def create_db
  abort "server not running".red unless check_pid
  abort "CLICKHOUSE_DB env not set".red if CLICKHOUSE_DB.empty?
  abort "GOOGLE_STORAGE_BUCKET env not set".red if GOOGLE_STORAGE_BUCKET.empty?
  abort "GOOGLE_STORAGE_HMAC_KEY_ID env not set".red if GOOGLE_STORAGE_HMAC_KEY_ID.empty?
  abort "GOOGLE_STORAGE_HMAC_KEY_SECRET env not set".red if GOOGLE_STORAGE_HMAC_KEY_SECRET.empty?
  run_query("CREATE DATABASE IF NOT EXISTS #{CLICKHOUSE_DB}")
end

def create_tables
  tables.each do |table, filename|
    if run_query("SHOW TABLES LIKE '#{table}'").empty?
      print "creating " + File.basename(filename).underline + "... "
      output = run_query(filename)
      if $?.success?
        puts "ok!".green
      else
        abort "ERROR".red + "\n\n#{output}"
      end
    end
  end
end

def drop_tables
  run_query("SHOW TABLES").lines.map(&:chomp).each do |table|
    run_query("DROP TABLE #{table}")
  end
end

# use the client
def client
  if CLICKHOUSE_DB.empty?
    system("cd #{WDIR}/clickhouse && ./clickhouse client --database #{CLICKHOUSE_DB}")
  else
    system("cd #{WDIR}/clickhouse && ./clickhouse client")
  end
end

# load data matching a google cloud storage glob
def load(glob)
  tables.keys.each do |table|
    gs_uri = "gs://#{GOOGLE_STORAGE_BUCKET}/#{glob}/#{table}_*.parquet"

    print "loading " + gs_uri.underline + "... "
    output = run_query("INSERT INTO #{table} SELECT * FROM s3('#{gs_uri}')")

    if $?.success?
      puts "ok!".green
    else
      abort "ERROR".red + "\n\n#{output}"
    end
  end
end

def create_materialized_view(name)
  path = "#{WDIR}/materialized_views/#{name}.sql"
  file = File.basename(path)
  abort "materialized view #{file} not found".red unless File.exist?(path)

  print "creating materialized views " + file.underline + "... "
  output = run_query(path)

  if $?.success?
    puts "ok!".green
  else
    abort "ERROR".red + "\n\n#{output}"
  end
end

# entrypoint
case ARGV[0]
when "start"
  start
when "daemon"
  start(true)
when "stop"
  stop
when "setup"
  create_db
  create_tables
when "reset"
  create_db
  drop_tables
  create_tables
when "client"
  client
when "load"
  create_db
  create_tables
  if ARGV[1] == "latest"
    ((Time.now.utc.to_date - 29)..Time.now.utc.to_date).each do |day|
      load(day.strftime("%Y/%m/%d"))
    end
  elsif ARGV[1].match?(/\A20[0-9\/\*]+\z/)
    load(ARGV[1])
  else
    usage
  end
when "queue"
  create_db
  create_tables
  create_materialized_view(ARGV[1])
else
  usage
end
